# 6장. 메세지와 인터페이스

## 메세지와 메서드
* 클래스 사이의 정적인 관계가 아닌 메세지 사이의 동적인 흐름을 봐야한다.
* 애플리케이션은 클래스로 구성 되지만 메세지로 정의된다.

## 용어정리
* 메세지
  * 전송, 패싱
  * 전송자, 수신자
  * 오퍼레이션명, 인자

* condition.isSatisfiedBy(screening) -> 수신자.오퍼레이션명(인자)
* 이처럼 메세지를 수신했을 때, 실제로 실행되는 함수 or 프로시져를 메서드라 부른다.

객체지향은 전송과 호출을 모호하게 만든다.
컴파일 시점과 실행되는 코드가 분리되기 때문이다.

-> 전송자와 수신자의 결합을 느슨하게 만든다.

## 인터페이스와 오퍼레이션
객체가 의사소통을 위해 공개하는 메세지 집합은 퍼블릭 인터페이스, 내부에 포함된 메세지를 오퍼레이션 이라 한다.

퍼블릭 인터페이스와 메세지 관점에서는 메서드를 호출하는 것이 아닌 오퍼레이션을 호출하는 것이다.

1. Client 가 메세지 전송
2. operation 호출
3. 메서드 실행

## 인터페이스 설계와 품질
### 디미터 법칙
* 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것.
  * Java, C# 에서 '도트(.)'은 오직 하나만 사용
### 묻지 말고 시켜라
* 객체 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.
  * 객체 내부에서 결정하는 것이 정보 전문가에게 결졍을 맏기는 것이고 이는 응집도가 높아진다.
### 의도를 드러내는 인터페이스
1. 메서드 명에 작업 내용 명시 -> 작업 내용에 변경에 따라 변해야 하기 때문에 변경에 취약하다
2. '어떻게 하는 가'가 아닌 '무엇을 하는 가'로 설계 -> 변경에 유연하게 대처할 수 있다.

* 같은 동작을 한다면 메서드 명을 같게 한다
* java는 정적타입 언어기 때문에 인터페이스로 묶어줄 필요가 있다.

## 원칙의 함정
* 법칙에는 예외가 없지만 원칙에는 예외가 넘친다.
* 상황에 부적합 하다면 과감하게 원칙을 무시해야 한다.

ex) 디미터 법칙을 지키려고 무조건 도트는 한번만?
1. 스트림 같은 경우 예외다.
2. 디미터 법칙을 지키는 코드가 본질적인 책임을 벗어난다면 트레이드 오프를 고려해 설계해야 한다.

## 명령-쿼리 분리 원칙
* 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
* 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

명령과 쿼리가 동시에 있다면 예측하기 힘들어지고 버그를 찾기 힘들어 진다.

부수효과(side effect)가 없는 코드로 설계해 불변성을 가져가야 참조 투명성을 만족 할 수 있다.