# 메시지와 인터페이스

> 객체지향 애플리케이션은 객체들이 주고받는 메시지가 가장 중요하다!

- 입문 개발자들은 분석, 설계, 구현을 아우르는 전체 개발 활동의 중심에 클래스를 놓는다.
- 클래스가 실제적이고 구체적인 도구이지만 말 그대로 도구이기에 여기에 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높음
- 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아닌 객체를 지향해야함. 즉, 협력 안에서 객체가 수행하는 `책임`에 초점을 맞춰야 함
  - 책임이 객체가 수신할 수 있는 메시지의 기반이 됨.

## 협력과 메시지

### 클라이언트-서버 모델

> 독립적으로 수행할 수 있는 것보다 더 큰 책임이 있으면 다른 객체와 메시지를 통해 협력해야한다!

- 객체가 다른 객체에 접근하는 유일한 방법은 메시지를 전송하는 것이며, 객체는 자신의 희망을 메시지라는 형태로 전송하고 메시지를 수신한 객체는 요청을 적절히 처리하여 응답하는 협력 과정을 거친다.
- 이런 관계를 `클라이언트-서버 모델`이라 칭할 수 있다.
  - 전송 객체: 클라이언트
  - 수신 객체: 서버
- 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.
- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이며 두 가지 종류의 메시지 집합을 구성
  1. 객체가 수신하는 메시지의 집합
  2. 외부의 객체에게 전송하는 메시지의 집합
- 수신하는 메시지 집합 외에도 외부에 전송하는 메시지의 집합도 함께 고려해야 함

### 메시지와 메시지 전송

> 메시지 전송 = 메시지 수신자, 오퍼레이션명, 인자의 조합!

- 메시지(message)는 객체들이 협력할 수 있는 유일한 의사소통 수단
- 한 객체가 다른 객체에게 도움을 요청하는 것은 `메시지 전송(message sending)` or `메시지 패싱(message passing)`
- 전송하는 객체는 `메시지 전송자(message sender)`, 수신하는 객체는 `메시지 전송자(message receiver)`라함
- 메시지는 `오퍼레이션명(operation name)`과 `인자(argument)`로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것임
- EX) condition.isSatisfiedBy(screening) <- 수신자.오퍼레이션명(인자)

### 메시지와 메서드

> 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다!

- 메서드를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가 달렸다.
  - DiscountCondition 인터페이스에 메시지를 보냈지만 실체는 PeriodCondition, SequenceCondition에 따라 다르다.
- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 `메서드`라고 함
- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있음.
- 그렇기에 우리는 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라 믿어야 한다.
- 이렇게 메시지 전송자는 자신이 어떤 메시지를 보낼지만 알면 느슨하게 결합될 수 있고, 어떤 인스턴슨지 어떤 요청이 몰라도 원활한 협력이 가능하다.
- 수신자 또한 누가 보냈는지 알 필요 없이 메시지가 왔단 것말 알고, 스스로 필요한 메서드를 결정하는 `자율권`을 누릴 수 있다.

### 퍼블릭 인터페이스와 오퍼레이션

- 객체가 의사소토을 위해 외부에 공개하는 메시지의 집합을 `퍼블릭 인터페이스`라고 함
- 메시지는 `오퍼레이션(operation)`이라 부르며, 수행 가능한 어떤 행동에 대한 추상화이다. 오퍼레이션은 내부 구현 코드는 제외하고 다순히 메시지와 관련된 시그니처를 가리킴
- 실제로 실행되는 코드는 메서드라고 부름
- 퍼블릭 인터페이스, 메시지 관점에선 메서드 호출보단 오퍼레이션 호출 후 메서드 실행이 된다고 보는게 더 적합

### 시그니처

- 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 `시그니처(signature)`라고 함
- 오퍼레이션은 실행 코드 없이 시그니처만 정의한 것

## 인터페이스와 설계 품질

- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스 조건을 만족해야 함
- 이를 위해선 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지하고, 메시지가 객체를 선택하게 해야함

### 디미터 법칙

> 오직 인접한 이웃하고만 말하라(don't talk to strangers)
> 오직 인접한 이웃하고만 말하라(only talk to your immediate neighbors)

- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것
- 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍
  - 메서드의 인자로 전달된 클래스(본인 클래스 포함)
  - 인스턴스 변수의 클래스
- 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야함
  - this 객체
  - 메서드의 매개변수
  - this의 속성
  - this의 속성인 컬렉션의 요소
  - 메서드 내에서 생성된 지역 객체
- 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있음을 유의해햐한다.

### 묻지 말고 시켜라(Tell, Don't Ask)

- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔선 안 됨
- 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 캡슐화를 위반하는 것
- 내부 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하면 그것은 책임이 외부로 누수된 것이다.
- 상태를 묻는 오퍼레이션은 행동을 요청하는 오퍼레이션으로 대체하라

### 의도를 드러내는 인터페이스

- 메서드를 명명하는 두 가지 방법
  1. 메서드가 작업을 어떻게 수행하는지 나타내도록 짓기
  2. 어떻게가 아닌 `무엇`을 하는지 드러내도록 짓기

## 명령-쿼리 분리 원칙

> 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다.

- 루틴: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
  - 프로시저(명령): 부수효과를 발생시킬 수 있지만 값을 반환할 수 없음. 객체의 상태를 수정
  - 함수(쿼리): 값을 반환할 수 있지만 부수효과를 발생시킬 수 없음. 객체와 관련된 정보를 반환
- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다 or 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
- 명령과 쿼리를 나눔으로써 부수효과를 분리할 수 있다.
- 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 `참조 투명성(referential transparency)`의 장점을 제한적이나마 누릴 수 있음
  - 참조 투명성: 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
    - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있음
    - 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않음