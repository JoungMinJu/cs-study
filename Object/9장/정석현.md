# Object 9장

# 9장. 유연한 설계

## 개방-폐쇄 원칙

> 소프트웨어 개체는 `확장`에 대해 열려 있어야 하고, `수정`에 대해서는 닫혀 있어야 한다.
>

`확장` - 요구사항 변경에 맞춰 새로운 동작기능 추가

`수정` - 기존 코드를 수정하지 않고 동작을 추가하거나 변경

어떻게 코드를 수정하지 않고도 새로운 동작을 추가할 수 있을까?

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일 타임 의존성에 관한 이야기다.

### 추상화가 핵심이다.

핵심은 `추상화에 의존하는 것`이다.

추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.

<aside>
💡 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야 한다.

</aside>

## 생성 사용 분리

결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다.

사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.

### Factory 추가하기

생성 책임을 Client로 옮긴 배경에는 Movie는 특정 컨텍스트에 묶여서는 안 되지만 Client는 묶여도 상관 없다는 전제가 깔려 있다.

Client에 객체 생성과 관련된 지식이 새어나가지 않기를 원한다면 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY 라고 한다.

## 의존성 주입

의존성 주입을 통해 생성과 사용을 분리할 수 있다.

필요한 의존성은 세 가지 방법을 통해 주입 받을 수 있다.

- 생성자 주입
- setter 주입
- 메서드 주입

## 숨겨진 의존성은 나쁘다.

의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 존재한다.

대표적인 방법은 SERVICE LOCATOR 패턴이다.

의존성 주입과 달리 객체가 직접 SERVICE LOCATOR 에게 의존성을 해결해줄 것을 요청한다.

이 패턴의 가장 큰 단점은 의존성을 감춘다는 것이다.

의존성을 숨기고 있기 때문에 생성자를 통해 객체가 만들어 졌음에 대한 확신을 가질 수 없다.

또한 정적 변수를 사용해 객체들을 관리하기 때문에 모든 단위 테스트 케이스에 걸쳐 sERVICElOCATOR의 상태를 공유하게 되어 서로 고립되어야 하는 단위 테스트의 기본 원칙을 위배한다.

## 추상화와 의존성 역전

의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을 최소화하도록 의존성을 관리해야 한다.

상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용 할 때 하위 수준의 클래스도 필요하기 때문에 재사용하기가 어려워진다.

추상화를 통해 상위 수준의 클래스와 하위 수준의 클래스 모두 추상화에 의존하게 만들어야 한다.

정리하자면

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다
2. 추상화는 구체적인 상황에 의존해서는 안된다. 구체적인 상황은 추상화에 의존해야 한다.

이를 의존성 역전 원칙 이라 한다.