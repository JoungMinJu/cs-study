# 4. 설계 품질과 트레이드오프

시스템을 객체로 분할하는 두 가지 방법

- **상태**(데이터)를 중심축으로 분할
- **책임**을 중심축으로 분할

## 데이터 중심 설계

- 인스턴스 변수로 클래스 안에 직접 포함
- 할인 정책을 별도의 클래스로 분리 x → 할인금액과 할인 비율을 직접 정의

### 데이터 중심 설계의 흐름

> 객체가 포함해야하는 데이터에 집중하는 형태
> 
- 인스턴스 변수로 클래스 안에 포함시키는 방식
    - Move가 필요한 데이터는? → 각 정책에 따라 필요한 것(할인 금액, 할인 비율)을 속성에 포함
    - 할인 정책에 대한 데이터는? → MoveType 의 enum class 정의하여 속성으로 포함
- 캡슐화 진행
    - 접근자(get) / 수정자(set) 추가

## 설계 트레이드 오프

궁극적인 목적 ⇒ 변경을 쉽게 하기 위함

### 캡슐화

- 캡슐화의 목적은 객체의 내부 구현을 외부로부터 감춤으로써 변경의 여파를 통제하는 것
- 변경될 가능성이 높은 부분을 **구현 → 내부에 숨김**
- 안정적인 부분은 **인터페이스 → 공개**

👉 즉, 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것

### 응집도와 결합도

- 응집도 : 모듈에 포함된 내부 요소들이 연관돼 있는 정도
- 결합도 : 의존성의 정도를 나타냄. 다른 모듈에 대해 얼마나 많은 지식을 갖고있는지에 대한 척도
- 좋은 설계는 높은 응집도와 낮은 결합도로 구성

## 데이터 중심 설계의 문제점

- 캡슐화 위반
- 높은 결합도
- 낮은 응집도

### 캡슐화 위반

- 추측에 의한 설계 전략
    - 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측으로 설계 진행
    - 과도한 접근자(get)와 수정자(set) 메서드를 추가하는 경우가 여기에 해당
    - 결과적으로는 대부분의 내부 구현이 퍼블릭 인터페이스에 노출되는 구조

### 높은 결합도

- 캡슐화 위반으로 수반되는 문제
    - 예약 class에서 getFee()의 반환 타입을 Money타입의 Rfee에 저장하는 경우
    - Rfee의 타입이 바뀌면 getFee()가 반환하는 타입도 바꿔야 함
    - 이는 getFee() 메서드가 fee를 정항적으로 캡슐화하지 못하는 것을 의미
    - fee의 가시성은 private으로 되어있지만 public으로 변경한 것이나 마찬가지인 셈

### 낮은 응집도

- 캡슐화 위반으로 수반되는 문제2
- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존하는 경우가 해당
- 즉, 서로 다른 이유로 변경되는 코드 ⇒ ‘책임’을 의미한다고 볼 수 있음 (단일 책임의 원칙)
- 이렇게 되는 경우 하나의 조건을 변경할 때 하나 이상의 클래스를 동시에 수정해야 함

## 자율적인 객체를 향해

### 캡슐화를 지켜라

- get / set으로 접근하는 것이 아닌 객체가 스스로 책임지도록 하는 것
    - 외부 객체에서 get/set으로 접근해 Rectangle을 구성하는 것이 아닌
    - Rectangle 내부에서 스스로 너비와 높이를 조절하도록 ‘**책임을 이동시키는 것**’

### 스스로 자신의 데이터를 책임지는 객체

[객체 설계에 필요한 질문]

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

[예시]

- Movie가 필요한 데이터는? → a, b, c
- 이 데이터를 처리하기 위한 오퍼레이션은? a(), b(), c()
- 데이터에 필요한 메서드를 데이터 스스로 가지고 있는 객체 = 스스로 책임진다

## 하지만 여전히 부족하다

### 캡슐화 위반2

- 스스로 자신의 데이터를 책임지더라도 생기는 문제가 있음
- 해당 메서드의 파라미터를 통해 인스턴스 변수를 노출하는 경우 (파라미터로 인스턴스 변수를 받는 경우)
- 인스턴스의 속성을 변경하면 → 메서드의 파라미터 또한 수정 → 메서드를 사용하는 클라이언트도 수정
- 이처럼 내부 구현 변경이 외부로 퍼져나가는 현상을 **파급효과**라 함
- 이는 캡슐화가 부족하다는 명백한 증거

❓ 그렇다면 파라미터에 인스턴스 변수를 넣지 않으면 되는 것인가?

→ 그렇지 않음. 메서드를 통해 속성이 노출된다면 그것 또한 실패한 캡슐화

- playTennis(), playSoccer(), playPingPong() 등 속성이 그대로 노출되는 메서드
- 여기에 playBasketBall()이 추가되거나 playTennis()가 제거되면 **의존하는 모든 클라이언트가 영향을 받게 될 것**

### 높은 결합도2

- A클래스와  B클래스의 결합이 높을 수록
- A클래스의 구현(숨긴 것)을 변경하는 경우에도 B클래스도 함께 변경해야하는 경우가 생김

### 낮은 응집도2

- 캡슐화 위반으로 인한 파급효과 발생
- 여전히 하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 함

👉 결국 데이터 중심의 설계를 개선하더라도 문제점이 발생함

## 왜 데이터 중심으로 설계하면 문제점이 생길까

- 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션 결정
