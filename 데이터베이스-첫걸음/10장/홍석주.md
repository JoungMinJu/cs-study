# 성능 생각하기

## 성능

- 시스템 세계에서 성능은 2가지의 지표(메트릭스)에 의해 측정됨
  - 처리 시간(응답 시간): 어떤 특정 처리의 시작부터 종료까지 걸린 시간
  - 처리율: 특정 처리(트랜잭션)를 단위 시간에 몇 건 처리가 가능하지를 나타내는 단위 EX) 초당 50건의 트랜잭션 -> 50 TPS(Transaction Per Second). 처리율에선 초당/시간당 같은 단위 시간이 필요함
- 처리율이 성능에서 중요한 이유는 시스템의 자원 용량(Resource Capacity)를 결정하는 요인이기 때문. 처리율이 높은 시스템일수록 CPU나 메모리 같은 하드웨어 자원이 많이 필요하다.
- 동시 실행 처리 수가 늘어나는데 한 가지 자원이라도 한계에 이르는 시점이 오면 성능이 떨어진다. 이때 최초의 한계에 이른 자원을 버틀넥 포인트(Bottleneck Point), 병목이라 부른다.
- Peak(정점): 동시에 실행되는 처리가 가장 많아지는 순간. 피크 타임을 대비하지 않으면 서비스가 극단적인 지연이 일어날 수 있음
- Breaking Point(한계점): 처리율과 응답 시간이 극단적으로 나빠지기 시작하는 처리량
- Sizing(사이징), Capacity Planning(캐퍼시티 플랜): 한계점을 대비하기 위해 정점을 상정한 자원 확보
- 주기형과 돌발형에 맞게 자원을 확보해야하는데 이는 사실 쉽지 않음. 그에 맞는 대비책으론 클라우드 서비스(AWS, Azure)를 사용해서 스케일 업(Scale Up, 고성능 장비 도입)이나 스케일 아웃(Scale Out, 장비 추가 도입)을 통해 유연하게 대비를 한다.

## 성능을 결정하는 요인

### 옵티마이저가 참조하는 통계 정보

- 통계정보(Statistics)는 옵티마이저, 실행계획과 더불어 성능에 큰 영향을 주는 개념으로 옵티마이저가 실행계획을 세울 때 참조하는 정보이다. 통계정보는 아래의 데이터를 구성하고 있다.
  - 테이블의(대강의) 행수, 열수
  - 각 열의 길이와 데이터형
  - 테이블 크기
  - 열에 대한 기본키나 NOT NULL 제약 정보
  - 열 값의 분산과 편향
- 통계정보는 어림잡아 알려주는 값이기 때문에 정확하진 않을 수 있다. 통계정보를 정확히 하기 위해 테이블 풀 스캔을 하면 배보다 배꼽이 더 커질 수 있으니 주의하자

## 실행계획은 어떻게 세워지는가

- 실행 계획을 보고 싶으면 SQL 앞에 EXPLAIN을 붙이면 볼 수 있다.

> EXPLAIN SELECT * FROM city;

```sql
+----+-------------+--------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
| id | select_type | table  | type  | possible_keys | key       | key_len | ref  | rows   | Extra       |
+----+-------------+--------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | City   | ALL   | NULL          | NULL      | NULL    | NULL | 500866 | Using index |
+----+-------------+--------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
```

- type: 테이블 액세스 방법을 나타내며 풀 스캔(ALL)과 레인지 스캔(range) 2가지가 있음. 테이블 스캔은 테이블에 포함된 레코드를 처음부터 끝까지 전부 읽어들이는 방식으로 테이블 풀 스캔이라고도 함. 레인지 스캔은 테이블의 일부 레코드만 액세스 하는 방법
- possible_keys, key: 인덱스를 사용할 수 있으면 possible_keys에 인덱스 목록들이 나오고, key에서 적용된 인덱스가 무엇인지 표시 됨

```sql

-- SHOW INDEX FROM 테이블 적용 시

+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table  | Non_unique | Key_name  | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| titles |          0 | PRIMARY   |            1 | emp_no      | A         |      251150 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| titles |          0 | PRIMARY   |            2 | from_date   | A         |      334215 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| titles |          0 | PRIMARY   |            3 | title       | A         |      500866 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| titles |          1 | ix_todate |            1 | to_date     | A         |        4813 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+--------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
```

- 인덱스 생성 시 명령어는 `CREATE INDEX [인덱스명] ON [테이블명]([열명])`
- SQL에서 내부적으로 정렬을 발생하게 하는 처리는 다음과 같이 있음. 해당 키에 인덱스가 있으면 정렬을 건너뛰어 효율화 작업을 이룰 수 있음 (EXTRA - Using temporary; Using file sort <- 정렬을 위해 임시 영역에 파일 작성)
  - GROUP BY
  - 집약 함수(COUNT/SUM/AVG 등)
  - 집합 연산(UNION/INTERSECT/EXPECT)

### 인덱스의 구조

- 인덱스는 데이터베이스 성능 튜닝할 때 1순위적으로 고려하는 사항이며 비앵 대비 성능이 높은 이유는 아래와 같음
  - SQL문을 변경하지 않아도 성능을 개선할 수 있음
  - 테이블의 데이터에 영향을 주지 않음
  - 일정한 (때로는 극적인) 효과를 기대할 수 있음
- 인덱스는 보통 B-TREE 구조로 이루어져 있음
  - B-TREE는 노드로 구성되어있고, 루트 노드, 브랜치 노드, 리프 노드로 트리 형태로 구성되어있음
  - B-TREE는 무조건 정렬이 되어있어야 하며 이를 통해 고속의 탐색이 가능한 것이다.
  - B-TREE는 Balanced있게 LEVEL을 조정해주기 때문에 성능 불균형이 작게 일어나도록 되어있다.
  

### 인덱스 사용 주의사항

- B-Tree 인덱스는 좋지만 무작정 만들면 오히려 성능 악화로 이어질 수 있다. 크게 두 가지로 나뻐지는 경우가 있음
- 인덱스 갱신의 오버헤드로 갱신 처리의 성능이 떨어짐
  - 인덱스는 테이블에 새로운 데이터가 추가되거나 갱신, 제거가 실행되면 자동으로 인덱스 자신도 갱신하게 됨
  - 이로 인해 인덱스 갱신이라는 부수적인 오버헤드가 발생
  - 통상 1행 정도 갱신, 제거로 인한 인덱스 갱신은 얼마 안 걸리지만 누적되면 많이 걸리게 된다.
  - SELECT문을 고속화할 수 있지만 INSERT, UPDATE 갱신 SQL의 속도가 느려질 수 있으니 테이블 상황에 맞게 작성 필요
- 의도한 것과 다른 인덱스 사용
  - 한 개의 테이블에 복수 인덱스가 작성된 경우 발생하는 문제
  - 인덱스 후보가 많아지면 옵티마이저도 헤매게 되니 너무 많은 인덱스를 만들지 않도록 유의

### 인덱스 만들 때 기준

- 인덱스는 조회와 갱신, 제거 간의 트레이드오프가 항상 발생하기 때문에 균형있게 작성해야 한다.
- 크기가 큰 테이블만 만든다.
  - 크기가 작은 테이블은 애당초 인덱스나 풀 스캔의 차이가 무의미함
- 기본키 제약이나 유일성 제약이 부여된 열에는 불필요함
  - 기본키 제약이나 유일성 제약이 걸린 열은 자동으로 인덱스가 작성되어 있음
- Cardinality가 높은 열에 만든다
  - 중복도가 낮은 데이터가 Cardinality가 높다 보면 된다. 
  - 자동차 운전 면허는 유일하기 때문에 중복도가 낮아 카디널리티가 높은 반면, 성별은 남자와 여자 두 개로만 이루어졌기에 카디널리티가 낮고 이럴땐 오버헤드만 증가하기에 그냥 테이블 풀 스캔이 나을 수 있다.