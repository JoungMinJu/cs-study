# 백업

## 지속성과 성능이 양립하는 구조

- 트랜잭션의 D는 지속성(Durability)로 일련의 데이터 종작을 완료하고 완료 통지를 사용자가 받은 시점에서 그 동작이 영속화 되어 결과를 잃어버리지 않아야 한다. 이는 시스템이 정상일 때뿐만 아니라 DB 서버나 OS의 비정상적 종료 등의 시스템 장애에도 견딜 수 있음을 의미한다.
- DBMS에서 데이터를 보존하는 기억장치는 대부분 하드디스크. 하드디스크에서 지속성을 실현하려면 쓰기를 **동기화 쓰기**로 하면 조히만, 성능 면에서 좋지 않기에 지속성과 성능이 양립하도록 몇 가지 구조 사용
  - 로그 선행 쓰기(WAL, Write Ahead Log): 데이터베이스의 데이터 파일 변경을 직접 수행하지 않고, 우선 로그로 변경한 내용을 기술한 로그 레코드를 써서 동기화하는 구조. (MySQL, InnoDB 로그)
    - 디스크에 연속해서 쓰기 때문에 무작위로 쓰는 것보다 성능이 좋다
    - 디스크에 쓰는 용량과 횟수를 줄일 수 있다
    - 데이터베이스 버퍼를 이용해 데이터베이스의 데이터 파일로의 변경을 효율성 높게 수행
  - 데이터베이스 버퍼: 커밋 시 WAL 변경 내용을 쓰기 때문에 데이터 파일의 변경 내용은 트랜잭션이 커밋되면서 동시에 동기화할 필요 없지만, 트랜잭션 버퍼를 취해 비동기적인 쓰기를 하면 로그와 데이터 파일 간 일관성을 유지하기 어려움. DBMS에선 데이터베이스 버퍼를 준비해 데이터 파일로의 입력을 데이터 베이스 버퍼 경유로 일원화해서 단순화 함
    1. 갱신 대상의 데이터를 포함한 페이지가 버퍼 풀에 있는지를 확인하고 없다면 데이터 파일로부터 읽어 들인다.
    2. 버퍼 풀의 해당 페이지에서 갱신을 수행한다.
    3. 2의 갱신 내용이 커밋과 함께 로그에 기록된다. 버퍼 풀에 갱신되었지만, 아직 데이터 파일에 써지지 않은 페이지는 버퍼 풀 내에서 더티 페이지로 다룬다.
    4. 데이터 페이지는 나중에 적당한 타이밍에 정리되어 데이터 파일로 써진다. (체크포인트)
    5. 4의 체크포인트 이전 로그 파일은 불필요해지고, 갱신과 더불어 1부터 순서가 반복됨
  - 크래시 복구: 크래시가 발생하면 다음과 같은 상태가 된다. 크래시 이후 MySQL ㅅ버를 재시작하면 3과 1의 체크포인트 이후 갱신 정보를 사용해 데이터베이스 파일을 크래시 때까지 커밋된 최신상태로 수정 (롤 포워드, Roll-Forward)
    - WAL: 마지막으로 커밋된 트랜잭션의 갱신 정보를 가짐
    - 데이터베이스 버퍼: 크래시로 내용이 전부 소실됨
    - 데이터베이스 파일: 최후 체크포인트까지의 갱신 정보를 가짐

> 논리적인 파괴(DDL 문에 따른 테이블의 파기)나 물리적인 파손(디스크 장치의 고장 등)에는 대응할 수 없기에 DB가 정상적으로 동작하고 있을 때 주기적으로 백업하고 이를 이용해 복원이나 복구하는 것이 좋다.

## 백업과 복구

### PITR(Pointin-time Recovery)

- DB에서 데이터를 다양한 장애에서 지키려면 데이터베이스가 정상적으로 동작할 때 백업하고, 장애가 발생하면 백업으로 복원하여 백업 시점으로 되돌릴 수 있음

|DBMS|Oracle|MySQL|PostgreSQL|DB2|SQL Server|
|----|------|-----|----------|---|----------|
|로그이름|REDO 로그|바이너리 로그|WAL 로그|트랜잭션 로그|트랜잭션 로그|
|아카이브 지정|O|X|O|O|O|
|아카이브 시 이름|ARCHIVELOG|X|WAL 아카이브|아카이브 로깅|완전복구 모델|
|비 아카이브 시 이름|NOARCHIVELOG|X|없음|순환 로깅|완전 복구 모델|

### 백업의 3가지 관점

- 장애가 발생하면 데이터를 이용할 수 없기에 정상적인 상태일 때 어딘가에 백업 해두고 신속하게 복원(Restore) 해두어야 함
- 백업을 수행하는 3가지 관점
    1. 핫 백업과 콜드 백업
        - 핫 백업: 온라인 백업이라도 하며, 백업 대상 DB를 정지하지 않고 가동한채로 백업 데이터를 얻음
        - 콜드 백업: 오프라인 백업이라 불리며 정지 후 백업 데이터 얻음
    2. 논리 백업과 물리 백업
        - 논리 백업: SQL 기반의 텍스트 형식으로 백업 데이터가 기록/편집 가능
        - 물리 백업: 데이터 영역을 그대로 덤프하는 이미지로 바이너리 형식으로 기록
    3. 풀 백업과 부분(증분/차등) 백업
        - 풀 백업: 전체 백업, 데이터베이스 전체 데이터를 매일 백업하는 방식
        - 부분 백업: 풀 백업을 한 후에 이후 갱신된 데이터를 백업
