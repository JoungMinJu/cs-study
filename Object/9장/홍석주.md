# 유연한 설계

## 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 **확장**에 대해 열려 있어야 하고, **수정**에 대해서는 닫혀 있어야 한다.
  - 확장에 대해 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 **동작**을 추가해서 애플리케이션의 기능을 확장할 수 있음
  - 수정에 대해 닫혀 있다: 기존의 **코드**를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

> 유현한 설계는 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경

- 런타임 의존성은 실행 시에 협력에 참여하는 객체들 사이의 관계
- 컴파일타임 의존성은 코드에서 드러나는 클래스들 사이의 관계
- 8장에서 컴파일타임에는 DiscountPolicy에만 의존하지만 실제 객체에선 AmountDiscountPolicy, PercentDiscountPolicy를 쓰며 나아가선 OverlappedDiscountPolicy라는 새로운 클래스를 만들어 런타임 객체로 넣어주었다. 이처럼 새로운 클래스를 추가하여도 수정이 일어나지 않는 **닫혀있는 상태**를 볼 수 있음
![Alt text](image.png)

### 추상화가 핵심

- 개방-폐쇄 원칙의 핵심은 추상화에 의존
- 추상화: 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법. 
  - 이 과정을 거치면 문맥이 바뀌어도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략됨
  - 생략된 부분은 문맥에 적합한 내용으로 채워넣음으로 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있음

```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();

    public DiscountPolicy(DiscountCondition... conditions) {
        this.conditions = Arrays.asList(condition);
    }

    public Money calculateDiscountAmount(Screening screening) {
        for (DiscountCondition each: conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }
        return screening.getMovieFee();
    }

    abstract protected Money getDiscountAmount(Screening screening);
}
```

- 위 코드에서 변하지 않는 부분은 할인 여부 판단하는 로직이고, 변하는 부분은 할인된 요금을 계산하는 방법임. (**getDiscountAmount**) 
- 이렇게 추상화하고 생략된 부분을 추후 구체화하면 OCP를 지킬 수 있음
- 수정에 대한 영향을 최소하하기 위해선 모든 요소가 추상화에 의존해야 한다.
- 아래 Movie와 같이 추상화에만 의존해야 DiscountPolicy의 자식 클래스를 추가하더라도 영향을 받지 않음

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

> 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야만 함!

## 생성 사용 분리 (seperating use from creation)

- 아래와 같이 생성자 영역에 구현체를 들이다면 다른 구현체로 바꾸고 싶을 때 코드를 수정해야 하고 이는 OCP 원칙을 위반하게 된다.
- 알아야 하는 지식이 많아지면 결합도도 높아지는데, 특히 **객체 생성 시** 과도하게 높아질 수 있다.
- 물론 객체 생성은 불가피하기에 어디선가 객체 생성은 필요하다. **문제는 부적절한 곳에서 생성하여 발생!**

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee) {
        this.discountPolicy = new AmountDiscountPolicy;
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

- 유연하고 재사용 가능한 설계를 위해선 두 가지 책임을 서로 다른 객체로 분리해야함
  1. 객체를 생성하는 것
  2. 객체를 사용하는 것
- 사용으로부터 생성을 분리하는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것
- 클라이언트에 컨텍스트에 대한 지식을 옮김으로써 독립적으로 바꿀 수 있음

```java
public class Client {
    public Money getAvatarFee() {
        Movie avatar = new Movie("아바타",
                                    Duration.ofMinutes(120),
                                    Money.wons(10000),
                                    new AmountDiscountPolicy(...));
        return avatar.getFee();
    }
}
```

![Alt text](image-1.png)