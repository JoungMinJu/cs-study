# 2. 객체지향 프로그래밍
## 객체지향 프로그래밍
- 클래스가 아닌 객체에 초점을 맞춰서 설계
- 객체를 독립적인 존재가 아닌 기능 구현을 위한 ‘협력하는 공동체’로 봐야 함
- 이에따라 도메인 개념 구성 →  클래스 구조 설계
- 클래스를 구현할 때는 접근 제어를 적절하게 사용
    - 객체의 상태를 숨기고(private) 행동만 공개(public)
    - 구현 은닉을 통해 클라이언트가 필요한 부분만 공개

## 상속과 다형성
- 추상클래스를 의존하는 경우
    - 생성 시점에서 어떤 자식 클래스에 의존하는지 알 수 있음
    - 이는 코드의 의존성과 실행 시점의 의존성이 서로 다름을 의미 (객체지향 설계의 특징)
    - 의존성이 다르면 코드를 이해하기 어려워짐
    - 의존성의 양면성은 트레이드 오프 (설계가 유연해질수록 코드 이해도 하락 및 디비깅이 어려워짐을 명심)

### 상속과 인터페이스
- 부모 클래스가 제공하는 모든 인터페이스를 자식이 물려받을 수 있음
- 자식클래스는 부모클래스와 동일한 타입으로 간주됨(업캐스팅)

### 다형성
- 메세지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는 것
- 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있음을 의미
- 동일한 메세지를 수신했을 떄 객체의 타입에 따라 다르게 응답할 수 있는 능력
- 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점 가짐

### 인터페이스와 다형성
- 인터페이스를 구현하는 클래스들은 상속과 마찬가지로 동일한 타입으로 간주됨(업캐스팅)
- (자바의 경우)전체를 자식 클래스가 결정할 수 있도록 결정권 위임

## 추상화와 유연성
- 추상화는 요구사항의 정책을 높은 수준에서 서술할 수 있음 (전체적인 주요 흐름 파악)
- 추상화는 설계를 유연하게 만들 수 있음 (상속을 통한 새로운 기능 확장 용이)

### 상속의 단점
- 캡슐화 위반 (상속을 이용하기 위해서는 부모 클래스의 내부 구조를 파악하고 있어야 함)
- 유연하지 못한 설계 (부모-자식 클래스간의 관계를 컴파일 시점에서 결정, 실행 시점에 객체의 종류를 변경하는 것이 불가능)

### 합성
- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
- 인터페이스에 정의된 메세지를 통해서만 재사용이 가능 → 캡슐화
- 의존하는 인스턴스를 교체하는 것이 비교적 쉬움 → 설계의 유연성
- 상속은 클래스를 통해 강하게 결합되지만 합성은 메세지를 통해 느슨하게 결합됨
