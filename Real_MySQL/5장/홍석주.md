# 트랜잭션과 잠금

- 트랜잭션은 작업의 완정성을 보장해주는 것. 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에 원 상태로 복구해서 작업의 일부만 적용되는 현상 `Partial update`이 발생하지 않게 만들어주는 기능이다. -> 트랜잭션 특성인 `원자성 (All or Nothing)`

- 잠금은 동시성을 제어하는 기능이라 보면 된다. 여러 커넥션이 회원 정보 레코드를 동시에 변경하려 할 때 Lock을 통해 선점한 커넥션이 작업할 수 있게 하는 것이다. 즉 한 시점에는 하나의 커넥션만 변경할 수 있게 해준다.

- MyISAM이나 MEMORY는 트랜잭션 기능을 제공하지 않기에 InnoDB를 사용하자.

```sql
CREATE TABLE tab_myisam (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
INSERT INTO tab_myisam (fdpk) VALUES (3);

CREATE TABLE tab_innodb (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=INNODB;
INSERT INTO  tab_innodb (fdpk) VALUES (3);


SET autocomit=ON;

INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
```

이 경우 둘다 Duplicte ERROR를 띄우긴 하지만, MyISAM은 ROLLBACK이 이뤄지지 않고 1, 2가 추가적으로 들어 가 있다. 이러면 개발자가 관리하기 더욱 어려워진다.

- 트랜잭션은 최소의 코드에만 적용하자. 즉 트랜잭션의 범위를 최소화하여야 한다. 아래의 경우를 봐보자.

```text
1) 처리 시작
=> 데이터베이스 커넥션 생성
=> 트랜잭션 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS에 저장
<= 트랜잭션 종료(COMMIT)
<= 데이터베이스 커넥션 반납
10) 처리 완료
```

이렇게 시작부터 트랜잭셕을 걸어서 대개 작업하는데, 사실 트랜잭션이 필요한 부분은 5, 6 정도다. DB 작업 외 네트워크 작업이 있는 곳까지 걸어버리면 의도치 않은 작동이 될 것이다. 그렇기에 최소 범위로만 트랜잭션을 걸어야 하고, 다음과 같이 줄여보자.

```text
1) 처리 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
=> 데이터베이스 커넥션 생성
=> 트랜잭션 시작
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
<= 트랜잭션 종료(COMMIT)
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
=> 트랜잭션 시작
9) 알림 메일 발송 이력을 DBMS에 저장
<= 트랜잭션 종료(COMMIT)
<= 데이터베이스 커넥션 반납
10) 처리 완료
```