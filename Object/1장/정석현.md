# 1장. 객체, 설계

## 이론 VS 실무
* 이론이 먼저 정립된 후에 실무가 뒤를 따라 발전할거 같지만 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다.
* 다른 공학 분야에 비해 상대적으로 짧은 소프트웨어 분야는 특히 설계, 유지보수에서 실무가 먼저 발전했다.


## 티켓 판매 어플리케이션
https://github.com/eternity-oop/object/tree/master/chapter01/src/main/java/org/eternity/theater/step01

### `절차지향`

모든 객체를 데이터 중심으로 설계하고, 한 객체에서 다른 객체들을 접근 및 판별하며 모든 비지니스 로직을 처리

### 문제점
모든 소프트웨어 모듈은 세 가지 기능을 수행해야 한다.
1. 제대로 동작
2. 변경에 유연
3. 의사소통이 쉬운 읽기 좋은 코드

* 위 티켓 판매 어플리케이션은 2, 3번을 만족하지 못하는 문제점을 포함한다.

  * 클래스 전체 or 일부 변수에 변경이 생기면 의존성이 높기 때문에 변경지점이 많다. - 2번 위반
  * 각 객체가 수동적인 존재로써, 예측가능한 일을 스스로 하지 않는다. - 3번 위반


### 개선
- 다른 객체에서 필드값을 비교(판단) 하는 것이 아닌 객체 스스로가 처리하는 자율적인 존재가 되도록 설계를 변경하자
- 필드의 접근을 막고(private) 퍼블릭 메서드(인터페이스)를 통해 접근 하도록 설계를 변경한다 → 캡슐화(encapsulation)

https://github.com/eternity-oop/object/tree/master/chapter01/src/main/java/org/eternity/theater/step02

객체가 자율적인 존재가 되면서 캡슐화가 가능해진다.

밀접하게 연관된 작업만 수행하며 응집도가 올라간다.

### 캡슐화와 응집도

- 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.
  - `자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.`

### 절차지향 VS 객체지향
step1처럼 다른 객체를 Data, Theater의 enter 메서드를 Process로 데이트와 프로세스를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라 한다.

step2 처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍이라 한다.


## 책임의 이동
Theater에 집중되어 있는 책임을 이동시킨다.

객체는 자신을 스스로 책임지게 해야 한다.

한 객체가 많은 의존(책임)을 가지고 있었던 설계(절차지향)에서 책임의 이동을 통해 자신의 데이터를 스스로 처리하는 설계(객체지향)로 변경했다.

설계를 어렵게 만드는 것은 `의존성` 이라는 것을 기억하자.

캡슐화를 통해 자율성을 높여 높은 응집도와 낮은 의존성을 갖는 훌륭한 객체지향 설계를 만들어 가자.

https://github.com/eternity-oop/object/tree/master/chapter01/src/main/java/org/eternity/theater/step03

### 새로운 의존성
`객체가 스스로 판별할 수 있게 하기 위해, 객체를 넘겨줌으로써 새로운 의존성이 생길 수 있다.`

`따라서 결합도 VS 자율성의 trade off 관계를 고려해 설계해야 한다.`

## 설계란?
코드를 배치하는 것.