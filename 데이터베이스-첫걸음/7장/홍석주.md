# 트랜잭션과 동시성 제어

## 트랜잭션이란

- 우리가 테이블을 갱신을 수행하기 위해 INSERT/DELETE/UPDATE를 사용하는데, **단일 쿼리만으로 구성하지 않고 보통 복수 쿼리를 연속적으로 수행하는 경우가 많음**
- 또한, 갱신 전의 데이터로 SELECT를 사용할 때 이를 포함해 복수 쿼리를 일관된 형태의 한덩어리로 관리해야 함.
- 트랜잭션은 이런 복수 쿼리를 한 단위로 묶은 것이라고 보면 된다.
- 트랜잭션 하면 보통 ACID 특성과 격리레벨, 3가지 부정합에 대해서 알아야 함

> MySQL에서 많이 알려진 엔진은 MyISAM과 InnoDB가 있는데, InnoDB만 트랜잭션을 사용할 수 있다.

## ACID

ACID는 다음의 단어의 앞 글자들을 따온 것이다.

- Atomicity(원자성)
- Consistency(일관성)
- Isolation(고립성 또는 격리성)
- Durability(지속성)

### Atomicity, 원자성

- 데이터의 변경(INSERT/DELTE/UPDATE)을 수반하는 일련의 데이터 조작이 전부 성공할지 전부 실패할지를 보증하는 구조를 의미
- All or Nothing으로 기억하면 좀 더 수월 
- 예를 들어 내가 부산으로 여행을 간다하면 다음 절차를 수행할 것이다.
  - 서울 -> 부산행 좌석 예매
  - 부산 숙소 예약
  - 부산 -> 서울행 좌석 예매
  - 1~3의 대금을 지급
- 4까지 전부 잘 진행되면 트랜잭션은 COMMIT을 실행해 처리를 확정
- 이렇게 하여 각 데이터의 조작은 영구적으로 저장되어 결과가 손실되지 않는다. 
- 만약 3번 과정을 진행 중 에러가 터진다면? ROLLBACK을 실행시켜, 1번 이전의 상황으로 돌아가야 한다. 이렇게 하여 데이터가 무결해질 수 있도록 해야함.

### Consistency, 일관성

- 데이터베이스는 오브젝트(테이블이나 데이터베이스 내 정의할 수 있는 것들)에 대해 각종 정합성 제약을 추가할 수 있음
- 이는 일련의 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는 일관성을 유지하기 위함
- EX) 사용자 식별 번호를 만들 때 유니크 제약을 걸어두어 중복된 번호를 사용할 수 없도록 할 수 있다.

### Isolation, 고립성(격리성)

- 일련의 데이터 조작을 복수 사용자가 동시에 실행해도 각각의 처리가 모순없이 실행되는 것을 보증한다.
- 격리성 없이 진행되면 이런 사태가 발생할 수 있음
- 만약 부산 호텔에 남은 방이 10개 있을 때의 예약 흐름
  - 현재 방의 수를 확인한다. 10개 조회 (select)
  - 빈 방에서 1을 빼고 결과를 갱신해준다. 9개로 갱신 (update)
  - 근데 여기서 사용자 A와 B가 극적으로 동시에 수행하게 되면, 둘 다 10개를 조회하고 9개로 업데이트하여 방 수는 1개만 줄어들게 된다.

- 이런 사태를 방지하기 위해 DB에서는 오브젝트인 테이블에 대해 잠금(Lock)을 걸어 후속 처리를 블록(Block)할 수 있음
- 잠금 단위는 테이블 전체, 블록, 행 등이 있는데 MySQL에선 트랜잭션 처리를 할 때 주로 행 단위의 잠금이 이용됨
- 사용자 A가 1번의 과정을 처리할 때 SELECT ~ FOR UPDATE구문을 통해 방 수에 대해 잠금을 걸어두면 사용자 B는 A의 처리가 끝나 잠금을 획득할 때까지 대기하게 되며, 이렇게 하여 정상적인 방 수를 갱신할 수 있게 된다.

- 또한, InnoDB의 경우에는 MVCC 구조로 동작하기 때문에 단순 값 참조의 경우엔 SELECT FOR UPDATE는 불필요하며 읽기는 블록되지 않는다. 테이블을 갱신하는 사용자가 소수고 참조하는 사용자가 많은 경우엔 사용자의 동시성, 병렬성이 높아진다.

- 격리성에는 여러 레벨이 존재하는데 ANSI에서 제시한 4개의 단계는 아래와 같다.

  - 커밋되지 않은 읽기 (Read Uncommitted)
  - 커밋된 읽기 (Read Committed)
  - 반복 읽기 (Repeatable Read)
  - 직렬화 가능 (Serializable)

- 직렬화 가능이 가장 엄격하며 숫자가 작아질수록 완화된다. 
- 격리 수준에 따라 3 가지의 데이터 부정합이 발생할 수 있고, 다음과 같다.

|현상|개요|
|--|--|
|더티 읽기(Dirty Read)|어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상.EX)사용자 A가 값을 변경하고 아직 커밋하지 않았는데, 사용자 B가 이 변경된 값을 읽는 것 사용자 A가 10에서 9로 바꿨는데, B가 바로 이 9를 읽어버린 것이다. 확정 전의 더럽혀진(Dirty) 데이터를 읽어서 붙여졌다.|
|애매한 읽기(Fuzzy/NonRepeatable Read)|어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽었는데, 2회 이후의 결과가 1회 때와 다른 현상. EX) 사용자 A가 10을 읽고, 즉후 B가 값을 9로 변경해 커밋하였다. 다시 A가 조회하니 10이 아닌 9를 읽어 온 것이다. 10이란 값이 보증되지 않고 읽을 때마다 값이 애매하게 (Fuzzy) 조회되는 것에 붙여졌다.
|팬텀 읽기(Phantom Read)|어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상 EX) 사용자 A가 범위 검색(빈 방이 10개 이상인 호텔) 하여 3행을 읽었다고 가정. 여기서 사용자 B가 그 범위에 들어가는 데이터 1행을 INSERT하고 커밋했다. 다시 A가 조회해보니 최조 SELECT해서 얻었던 3행이 아닌 4행이 선택된다. 이렇게 나타나거나 사라지는(DELTE/UPDATE) 데이터가 유령(Phantom) 같아 붙여졌다.|

- 위와 같이 3가지 부정합은 격리레벨에 따라 발생할 수 있는데 아래의 표와 같다.

|격리 수준|더티 읽기|애매한 읽기|팬텀 읽기|
|------|------|-----|----|
|커밋되지 않은 읽기|O|O|O|
|커밋된 읽기|X|O|O|
|반복 읽기|X|X|O|
|직렬화 가능|X|X|X|

### Durability, 지속성

- 트랜잭션이 COMMIT 된 후, 조작된 데이터에 대해 영구적으로 반영되어 그 결과를 잃지 않는 것을 말한다.
- 이는 시스템이 정상일 때나 DB, OS의 이상 종료 같은 시스템 장애에도 견딜 수 있는 것이다. 트랜잭션을 지원하는 DB들은 하드 디스크에 로그를 기록하고 시스템에 이상이 발생하면 그 로그를 활용해 이상 발생 전의 상태까지 복원할 수 있다.

> 물론 하드 같은 저장소 자체가 문제되면... RIP...

### 어떤것들은 다른 커넥션에서 왜 바로 보일까

- DDL에 따른 암묵적인 커밋

MySQL이나 Oracle에서는 CREATE TABLE과 같은 DDL 실행 시 암묵적인 커밋이 발행한다. 이 때문에 한 개의 커넥션에서 실행된 CREATE TABLE이 성공하면 그 이후에 다른 커넥션에서도 참조할 수 있게 된다.

- 오토커밋 설정

트랜잭션의 개시 (BEGIN TRANSACTION, START TRANSACTION, SET TRANSACTION 등)가 명시적으로 지정되지 않았을 때 트랜잭션을 구별하는 방법은 2가지가 있다.

하나의 SQL 문이 하나의 트랜잭션으로 구분됨 -> 이것이 오토 커밋 모드
사용자가 COMMIT 또는 ROLLBACK을 실행하기까지가 하나의 트랜잭션이 된다.
MySQL, PostgresSQL, SQL Server는 기본적으로 오토 커밋 모드로 되어있고 끌 수 있다.

> Oracle은 커밋을 해주어야 하는데, 나도 이걸 몰랐다가 분명 변경했는데 반영이 안돼서 뭔가 했더니 커밋이 안 된거였다. 이렇게 실수하면 락걸려서 서비스 장애가 생길 수 있으니 DBMS마다 차이를 잘 인지해야겠다.

## MVCC(Multi Versioning Concurrency Control)

- MySQL에서는 동시선 제어를 위해 MVCC를 사용하며 다음의 특성을 지님

1. 읽기를 수행할 경우 갱신 중이라도 블록되지 않는다
2. 읽기 내용은 격리 수준에 따라 내용이 바뀌는 경우가 있음
3. 갱신 시 배타적 잠금을 얻음. 기본적으로 행 단위이며, 트랙잭션이 종료할 때까지 유지됨
4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려고 할 때 블록된다. 일정 시간을 기다리며 그 사이에 잠금을 획득할 수 없는 경우 `잠금 타임 아웃` 됨
5. 갱신하는 경우 갱신 전의 데이터를 UNDO 로그에 유지한다.

## 잠금 타임아웃&교착 상태

### 잠금 타임아웃

- 갱신과 참조는 서로 블록하지 않지만, 갱신과 갱신의 경우에는 나중에 온 갱신이 잠금 대기 상태가 된다.
- 잠금 해제를 기다리는 쪽에서 값을 통해 얼마나 기다릴지 여부를 설정할 수 있음

> set innodb_lock_wait_timeout=1;

### 교착 상태

- 트랜잭션이 각각 특정 자원에 잠금을 걸고, 서로 잠금을 기다리며 발생하는 경우를 교착상태라고 함
- 일반적인 DBMS에서 교착 상태를 독자적으로 보고하며 이를 인식하여 시스템에 영향이 작은 쪽의 트랜잭션을 트랜잭션 개시 시점까지 롤백함
- 교착 상태의 빈도를 낮추려면 아래의 사항 고려
  - 트랜잭션 단위를 작게 하여 자주 커밋하기
  - 정해진 테이블 순서로 액세스하게 하기
  - 필요 없는 경우 읽기 잠금 획득을 지양하기
  - 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은 것으로 지정. EX) InnoDB의 격리 레벨을 REPEATABLE -> READ COMMITTED로 변경
  - 동시에 많은 연결에서 갱신 때문에 발생하면 테이블 단위로 잠금을 획득해 갱신을 직렬화. 대신 동시성은 떨어짐
  - MySQL은 테이블에 적절한 인덱스를 추가해 쿼리가 이를 이용. 인덱스가 사용되지 않을 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대해 잠금이 걸림

## 해서는 안 되는 트랜잭션 처리

- 오토커밋
  - 쿼리 단위로 커밋하는 설정.
  - MySQL의 새로운 연결은 모두 기본으로 오토 커밋임.
  - 대화형 도구 같은 툴 사용 시 간단하여 편하지만, 애플리케이션의 잠금을 실행하는 데는 커밋의 부하가 너무 높음
- 긴 트랙잭션
  - 동시성이나 자원의 유효성을 저하시킴
  - 대량의 갱신 처리를 한 개의 트랙잭션으로 처리하면 UNDO로그의 크기가 커짐. 또한, OS 파일 시스템에서 크기도 줄어들지 않기에 좋지 않음. 적당한 크기로 나누어서 커밋 하도록 처리 권장
  - 단순 SELECT 같이 트랜잭션이 필요없는 작업에서 (REPETABLE일 때) 불필요한 UNDO가 유지되기에 유의하기
  - 사용자와의 대화 처리를 집어넣으면 기다리는 시간으로 인해 시스템 전체 효율이 떨어짐. 필요한 경우 상한을 걸어 두기
  - 시스템의 성능이나 요건(갱신이 많은지, 조회가 많은지)를 잘 판단하여 적절한 커넥션 상한 수를 지정해야 함