메시지와 인터페이스

- 클라이언트 - 서버 모델
    - 객체가 다른객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것뿐.
    - 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포 = 클라이언트-서버 모델
    - 전송 = 클라이언트 / 수신 = 서버 → 단방향 상호작용
    - 
    <img width="601" alt="스크린샷 2023-09-13 오후 7 29 11" src="https://github.com/somefood/cs-study/assets/104557007/b6a8c136-50a8-43c1-9a80-957412137dbd">
    
    <img width="615" alt="스크린샷 2023-09-13 오후 7 29 26" src="https://github.com/somefood/cs-study/assets/104557007/7a4d7853-4d7a-4d0d-bfa7-b9e9a5d55f96">

  
    
    - 한 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행
    - 용어정리
        - 메시지 = 객체 협력하기 위한 의사소통 수단
        - 메시지 전송, 메시지 패싱 = 타 객체 도움 요청
        - 메서드 = 메시지를 수신했을 때 실제로 실행되는 함수
        - 실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라짐
        - 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮추고 확장 가능한 코드 작성 가능
    - 퍼블릭 인터페이스와 오퍼레이션
        - 퍼블릭 인터페이스 = 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
            - 퍼블릭 인터페이스에 포함된 메시지 = 오퍼레이션
                - 내부의 구현코드는 제외하고 단순히메시지와 관련된 시그니처를 가리키는 경우가 대부분.
            - 메시지를 수신했을 때 실제로 실행되는 코드 = 메서드
    - 시그니처
        - 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합친 것.
        - 오퍼레이션 = 실행코드 x
        - 메서드 = 구현까지 더한 것.
        - 일반적으로 메시지 수신 시 오퍼레이션의 시그니처와 동일한 메서드 실행
        - 오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.
- 인터페이스와 설계품질
    - 좋은 인터페이스 = 꼭 필요한 오퍼레이션만을 포함하고 무엇을 하는지 표현하는 것이 인터페이스
    - 디미터 법칙
        - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것.
        - 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 되어야 한다.
        - this, 메서드 매개변수, 메서드 내에서 생성된 지역 객체
        - <img width="564" alt="스크린샷 2023-09-13 오후 7 29 53" src="https://github.com/somefood/cs-study/assets/104557007/109af3da-f908-4de9-993d-ddf2b6265406">

            
            
            - 캡슐화가 무너지고 내부 구현에 강하게 결합된다.
        - <img width="599" alt="스크린샷 2023-09-13 오후 7 30 07" src="https://github.com/somefood/cs-study/assets/104557007/e9df7b35-feeb-4fdc-88f3-0a923ea7deac">

        - 객체가 자율적인 존재인 자신을 책임져야 된다.
        - 묻지 말고 시켜라
            - 수신자의 상태를 기반으로 결정을 내린 후 수신자의 상태를 바꿔서는 안된다.
            - 객체 외부에서 해당 객체의 상태를 기반으로 결정 내리는 것은 객체의 캡슐화 위반.
            - 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하며 인터페이스를 향상
            - 결국 중요한 것은 인터페이스에는 무엇을 하는지를 서술하는 것.
    - 의도를 드러내는 인터페이스
        - 메서드 명으로 무엇을 하는지를 드러내는 것.
            <img width="557" alt="스크린샷 2023-09-13 오후 7 30 23" src="https://github.com/somefood/cs-study/assets/104557007/4f88978e-4924-4312-8ba8-2ea754446d07">

            
        - 두 메서드가 동일한 목적을 가진다는 것을 메서드 이름을 통해 명확하게 표현
        
    - 원칙의 함정
        - 설계는 트레이드오프의 산물.
        - 원칙이 현재 상황에 부적합하다고 판단되면 원칙을 무시해.
        - 디미터 법칙
            - 결합도와 관련된것.
            - 여러개의 도트를 사용하는 것을 강제하는 것이 아님.
                <img width="512" alt="스크린샷 2023-09-13 오후 7 30 39" src="https://github.com/somefood/cs-study/assets/104557007/e77f8ca9-beb3-4fcc-a6d6-8bed90f3bcc5">

                
            - 동일한 클래스의 인스턴스만을 사용하고 또 다른 인스턴스로 변환하는 것.
            - 객체를 둘러싸고 있는 캡슐은 그대로 유지되는 것.
            - 내부 구현에 대한 어떤 정보도 외부로 노출하지 않으면 됨.
        - 묻지말고 시켜라
            - 클래스는 하나의 변경 원인만을 가져야 한다.
            - 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다.
    - 명령 쿼리 분리 원칙
        - 루틴 = 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
        - 루틴 = 프로시저 + 함수
        - 프로시저 = 절차에 따라 내부 상태를 변경하는 루틴의 한 종류
        - 함수 = 필요한 값을 계산해 반환하는 루틴의 한 종류
        - 프로시저 = 부수효과만 = 명령
        - 함수 = 값 반환만 = 쿼리
        - 명령 쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것.
            - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
            - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
        - **‘질문이 답변을 수정해서는 안된다.’**
        
        - isSatified가 명령과 쿼리의 두 가지 역할을 동시에 수행하고 있었기 때문에 버그를 찾기 어려움
            - 버그 찾기 어려움
        
    - 명령 쿼리 분리와 참조 투명성
        - 객체의 부수효과를 제어하기 수월해짐. 명령형 언어에 한해서 참조투명성의 장점을 얻을 수 있음
        - 참조투명성 = 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
            - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
            - 모든 곳에서 함수의 결괏값이 동일하기에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
    - **책임에 초점을 맞춰라 이게 정답.**
