# 7. 객체 분해

- 한 번에 다뤄야 하는 정보의 양 조절
    - 불필요한 정보를 제거하고 핵심만 남기기 → **추상화**
    - 해결 가능한 작은 문제로 나누기 → **분해**

## 프로시저 추상화와 데이터 추상화

- **프로시저 추상화** : 소프트웨어가 무엇을 해야 하는지를 추상화
- **데이터 추상화** : 소프트웨어가 무엇을 알아야 하는지를 추상화
- 프로시저 추상화 중심으로 분해
    - 기능 분해 (알고리즘 분해)
- 데이터 추상화 중심으로 분해
    - 타입 추상화 → 추상 데이터 타입
    - 프로시저 추상화 → 객체 지향
- 프로래밍 언어적 관점에서의 객체지향
    - 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것

## 프로시저 추상화와 기능 분해

### 기능 분해 관점에서의 시스템

- 기능 분해의 관점
    - 추상화 단위 : 프로시저
    
    <aside>
    💡 프로시저?
    
    - 프로시저란? 반복적 실행 or 유사하게 실행되는 작업들을 모아서 로직을 재사용하는 추상화 방법 (중복 방지)
    - 상세 정보를 모르더라도 인터페이스만 알면 사용할 수 있음
    </aside>
    
    - 하향식 접근법 사용
        - 시스템을 구성하는 최상위 기능을 정의하고 작은 단계인 하위 기능으로 분해해 나가는 방법
    - 즉 하향식으로 기능을 분해하는 방식(기능 중심으로 필요한 데이터를 결정하는 방식)을 사용하면 논리적이고 체계적인 트리 구조를 이룬다
    - 햐양식 기능 분해의 근본적인 문제점 : 변경에 취약
        - 시스템은 동등한 수준의 다양한 기능으로 구성되기 때문 (top 기능 존재 x)
        - 상위 함수가 강요하는 문맥에 하위 함수가 강하게 결합됨 (시간 절차적 흐름에 따라)
        - 데이터의 영향도를 파악하기 어려움 (의존성 관리가 안되어 있음)
    - 하양식 분해가 유용한 부분
        - 작은 프로그램과 개별 알고리즘 서술에 유용

## 정보 은닉과 모듈

- 정보 은닉 : 시스템을 모듈 단위로 분해하기 위한 원리
- 모듈은 변경 가능성이 있는 비밀을 내부로 감추고 변경되지 않을 퍼블릭 인터페이스를 외부로 노출 (책임의 할당)
- 모듈이 감춰야 할 비밀 : 복잡성, 변경 가능성
- 책임을 할당하여 모듈화했으면 → 내부 시스템은 기능 분해 적용
- 모듈의 장점
    - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
    - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다
    - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다
- 모듈의 한계
    - 태생적으로 변경을 관리하기 위한 구현 기법이므로 인스턴스 개념을 제공하지 않음
    - 이를 만족시키기 위해 등장한 개념이 추상 데이터 타입

## 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

- 과거 주된 추상화는 프로시저 추상화
- 한계를 극복하기 위해 데이터 추상화 개념 제안
    - 추상 데이터 타입으로 구현
    - 타입에 대해 여러개의 인스턴스 생성
- but 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있음
- 그렇다면 클래스는 추상 데이터 타입인가?

## 클래스

- 클래스는 추상 데이터 타입이 아니다
    - 클래스 : 상속과 다형성 지원하는 객체지향 프로래밍
    - 추상 데이터 타입 : 상속, 다형성 지원하지 않는 객체기반 프로그래밍
- 타입 추상화 : 오퍼레이션 기준으로 타입 통합
    - ex) `a(), b()`를 사용하는 Employee 타입 (A타입 직원, B타입 직원 캡슐화)
- 객체지향 : 타입을 기준으로 오퍼레이션 묶기 → 동일한 메세지에 다르게 반응할 수 있음(다형성)
    - ex) A Employee, B Employee가 사용할 공통 [`a(),b()`]

👉 객체 로직 분배에 있어서 정답은 없다. 타입을 빈번하게 추가할 경우 객체지향 기반을, 오퍼레이션을 빈번하게 추가할 경우 추상 데이터