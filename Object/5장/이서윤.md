# 5. 책임 할당하기
* 책임 중심 설계의 어려움은 어떤 객체에게 어떤 책임을 할당하는가? 이다
* 결국 최선의 방법은 상황과 문맥에 따라 달라진다

## 책임 주도 설계를 향해
* 책임 중심의 설계로 전환하기 위한 두 가지 원칙
    * 데이터보다 행동을 먼저 결정하라
    * 협력이라는 문맥 안에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라
* 질문의 순서를 바꿔라
    * 선 : "이 객체가 수행해야하는 책임은 무엇인가?"
    * 후 : "이 책임을 수행하는 데 필요한 데이터는 무엇인가?"

### 협력이라는 문맥 안에서 책임을 결정하라
* 객체에 적절한 책임을 할당하는 법
    * 객체의 입장이 아닌 **협력에 적합한 책임**을 할당
    * 이는 클라이언트 관점에서의 책임을 의미함 (이거 해.줘.)
    * 이를 위해선 메세지(해.줘) 결정 후 객체(해줄 사람) 선택하는 것 
    * 즉, '메세지가 존재하기 때문에 이를 처리할 객체가 필요하다'로 접근

### 책임 주도 설계
* 3장 요약 : **하청의 하청**

## 책임 할당을 위한 GRASP 패턴
* 책임 할당 기법 대중픽 → GRASP 패턴
* General Responsibility Assignment Software Pattern

### 도메인 개념에서 출발하기
* 핵심 비즈니스 로직부터 설계
* 개념들의 의미나 관계가 완벽할 필요는 없음
* 단지 설계 시작을 위한 참고서라고 봐도 됨

### 정보 전문가에게 책임을 할당하라
* 이를 수행하기 위해서는 전송자의 의도를 반영한 메세지를 전달해야 함
    * ex) 예매해줘
* 수신자를 선택할 때는 수신자가 **자율적인 존재 즉, 캡슐화된 단위**여야 함
    * ok, Sreening 객체가 해줄게
* 수신자는 책임 수행(메서드)과 이를 위한 상태를 모두 갖는 객체라는 것을 의미함
    * Screening이 해줘야 할 절차와 구현 고민
    * 스스로 처리할 수 없는 작업이 있다면 외부에 도움 요청 (새로운 하청업체 생성)
        * 예매는 내가 할게, 가격은 누가 계산해줄래?
            * 계산은 내가 할게, 할인 여부는 누가 판단해줄래?
* 이렇게 할당하는 방식을 **정보 전문가** 패턴이라 함

### 높은 응집도와 낮은 결합도
* 최선의 설계를 선택하려면 정보 전문가 패턴 외에 다른 패턴을 함께 고려해야됨
* 높은 응집도와 낮은 결합도를 얻을 수 있는 설계를 선택해야 함
* 이를 **Low coupling(낮은 결합도)** 패턴과 **high coupling(높은 결합도)** 패턴이라 함

### 창조자에게 객체 생성 책임을 할당하라
* 협력의 최종 결과물이 인스턴스 생성일 때 누군가는 생성할 책임을 할당받아야 함
* 이 경우 **creator(창조자)** 패턴 사용
* 창조자 패턴은 이미 필요에 의해 결합되어있는 객체에게 생성의 책임 또한 할당하는 것
* 그렇게 되면 전체적인 결합도는 변함이 없다

## 구현을 통한 검증
* 설계를 했다면 구현을 진행하고 올바르게 동작하는지 확인
* 앞서 언급한 방식대로 설계 진행
    * Screening이 Move에게 "계산하라" 메세지 전송 ```movie.calculateMovieFee()```

### 변경에 취약한 코드 개선
* 위와 같은 방식으로 설계했으나 변경에 취약한 클래스는 생기기 마련이다
* 변경에 취약한 클래스란 **코드를 수정해야 하는 이유를 하나 이상 가지는 클래스**
* 이를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해서 **클래스 응집도를 높여야 함**
    * 인스턴스 변수가 초기화 되는 시점 살펴보고, 초기화 시점이 다르다면 응집도가 낮은 것 → 초기화되는 속성의 그룹 기준으로 클래스 분리
    * 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉘면 응집도가 낮은 것  → 이들 그룹을 기준으로 클래스 분리

### 타입 분리하기
* 클래스의 응집도를 높히기 위해 타입을 분리
    * DiscountCondition을 SequenceCondition과 PeriodCondition으로 분리
    * 이렇게 되면 각 클래스에 있는 메서드는 자신의 모든 인스턴스 변수를 함께 초기화할 수 있게 됨 (응집도 상승)
    * 그러나 Movie의 경우 하나만 알았던 클래스를 2개나 알아야 하기 때문에 전체적인 결합도가 상승하는 문제 발생 (수정이 어려워짐)

### 다형성을 통해 분리하기
* Movie 입장에서 SequenceCondition과 PeriodCondition은 **할인 여부를 판단** 이라는 동일한 책임 수행 (단지 방법만 다를 뿐)
* 이를 하나의 **역할**로 묶어서 Movie가 역할에 대해서만 결합되도록 변경
* 즉, DiscountCondition이라는 인터페이스를 만들어서 SequenceCondition와 PeriodCondition를 추상화함
* 이를 **polymorphism(다형성)** 패턴이라 함

### 변경으로부터 보호하기
* 위와 같은 패턴으로 분리 시 DiscountCondition의 서브 클래스가 추가되더라도, 구현 메서드의 로직이 바뀌더라도, Movie는 영향을 받지 않음
* 이처럼 변경사항이 캡슐화되도록 책임을 할당하는 것을 **protected variations(변경 보호)** 패턴이라 함

### 변경과 유연성
* 변경에 대비할 수 있는 두 가지 방법
    * 코드를 이해하고 수정하기 쉽도록 단순하게 설계
    * 코드를 수정하지 않고도 변경을 수용할 수 있도록 설계
* 대부분은 전자가 더 좋은 방법이나, 유사한 변경이 반복적으로 발생하고 있다면 복잡성이 상승하더라도 유연성을 추가해야 함
* 상속 계층 안에 구현된 것들을 분리하여 추상화 → 합성 사용
    * ex) Movie 계층 안에 구현된 할인 정책을 DiscountPolicy로 분리 및 추상화 -> Movie에서 합성

## 4. 책임 주도 설계의 대안
* 최대한 빠르게 목적한 기능을 수행하는 코드를 작성
* 실행되는 코드를 얻은 후, 코드상에 명확하게 드러나는 책임들을 올바른 위치로 이동

### 메서드 응집도
* 긴 메서드는 이해하기도, 변경하기도, 재사용하기도 어려움 (설명하기 위한 주석만 늘어날 뿐...)
* 메서드를 작게 분해해서 메서드 응집도를 높여야 함

### 객체를 자율적으로 만들자
* 메서드들을 담고 있는 객체의 응집도가 낮다면, 변경의 이유가 다른 메서드들은 적절한 위치로 분배해야 함
* 적절한 위치란 **메서드가 사용하는 데이터를 정의하고 있는 클래스**를 의미
* 메서드를 이동시키고 메세지를 통해 협력하는 방식으로 구현
