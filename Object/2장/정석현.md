# Object 2장

# 2장. 객체지향 프로그래밍

https://github.com/eternity-oop/object/tree/master/chapter01/src/main/java/org/eternity/theater/step02

## 객체지향 프로그래밍을 향해

프로그램을 작성할 때는 , 클래스가 아닌 객체로 봐야한다.

객체는 상태,행동 관점과 렵력의 관점에서 바라봐야 한다.

### `가시성`

클래스를 구현할 때, 가시성을 구분하는 이유는?

1. `객체를 자율적인 존재로 만들어 객체를 객체를 신뢰하게 해야한다.`
    - 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아서는 안된다.
    - 객체에게 원하는 것을 요청하고 객체가 스스로 최선의 방법을 결정할 수 있을 것이라는 점을 믿고 기다려야 한다.
2. `객체를 사용하는 개발자에게 구현, 변경에 대한 자유를 제공 해야한다.`
    - 객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고, 자유롭게 구현을 변경할 수 있는 폭이 넓어진다. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.


> 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다.
>
>
> 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하라.(Ex) Long -> Money)
>

### 추상화

추상클래스를 통해 흐름 구현과 중간처리를 자식에게 위임하는 패턴을 템플릿 메서드 패턴이라 한다.

인터페이서 or 추상 클래스를 통해 Compile time에는 추상에 의존하고 Run time에는 구체 타입에 의존하게 만들면 이해하기는 어려워 지지만, 변경에는 유연해진다.

추상화라는 원리를 이용해 상속과 다형성을 이용해 객체지향적 프로그래밍을 실현한다.

- `가동성 VS 유연성 trade off`

### 상속과 인터페이스

자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다 -> `업캐스팅`

### 인터페이스와 다형성

구현을 공유할 필요(일부 추상화)가 있다면 추상 클래스를 사용하고,

구현은 공유할 필요가 없고 순수하게 인터페이스만 공유(전체 추상화)가 필요하다면 인터페이스를 사용해
다형적인 협력에 참여할 수 있다.

### 추상화와 유연성

1. `추상화를 통해 요구사항의 정책을 높은 수준에서 서술할 수 있다.`
2. `추상화를 이용하면 설계가 좀 더 유연해진다.`

### 코드의 재사용

코드를 재사용 하기 위해서는 상속보다 합성을 사용을 권장한다.

`재사용의 목적으로 상속을 사용하면 캡술화를 위반하고, 동적바인딩이 불가능하다.`

다른 객체를 인스턴스로 받는 합성을 사용해 유연성을 높이자.