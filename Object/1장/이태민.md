# Object

로버트 마틴의 소프트웨어 모듈의 세 가지 목적

- 실행 중에 제대로 작동하는 것. [모듈의 존재 이유]
- 변경을 위해 존재하는 것. → 그 모듈이 가동이 되는 기간 동안은, 변경될 수 밖에 없기 때문에 간단한 작업만으로도 변경이 가능해야 됨.
- 코드를 읽는 사람과의 의사소통 → 코드를 이해하기 쉬워야 한다.

객체 사이의 의존성.

---

- ‘변경’과 관련되어 있다.
- 의존성 = 변경에 대한 영향
- 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실.

**그럼 서로 완전히 의존하지 않게 하는것인가?**

---

→ NO

- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것.
- 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것을 목적으로 구현해야 된다.

**결합도 :**

객체 사이의 의존성이 과한 경우 = **결합도가 높다**

객체들이 합리적인 수준으로 의존할 경우 결합도가 낮다

설계의 목표 = 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것.

**캡슐화 :**

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것.

목적 : 

- 변경하기 쉬운 객체를 만드는 것.
- 객체 내부로의 접근을 제한하여 객체 사이의 결합도를 낮출 수 있다.

구현 : 

- A라는 객체가 내부에서 A 객체의 인스턴스를 포함하는 것.
- 가장 기본적인 설계 원칙 :
    - 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하는 것.
    

쉽게 생각해서 A라는 객체에서 B라는 객체를 사용하는 모든 부분을 B 내부로 모두 옮긴 것. 

즉, 자신이 처리하는 부분은 자신이 해결하게 하는 식으로 설계를 하는 것.

- 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것.

**응집도 :**

밀접하게 연관된 작업만을 수행하고 본인과 연관성 없는 작업은 **다른 객체에게 위임**하는 객체를 가리켜 **응집도가 높다.** 

→ 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도도 낮추고 응집도는 높일 수 있다.

절차적 프로그래밍 : 

프로세스와 데이터를 별도의 모듈에 위치시키는 방식

→ 쉽게 말해 결합도가 높아 A 객체가 다른 객체의 내부를 볼 수 있고, A 객체가 프로세스를 진행하고, 다른 객체들은 데이터의 개념처럼 작동하는 방식. 즉, 타 객체에 대해서 굉장히 의존적인 프로그래밍

<aside>
💡 변경하기 쉬운 설계? → 한 번에 하나의 클래스만 변경할 수 있는 설계

</aside>

- 이러한 관점에서, 절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점에 직면.

객체지향 프로그래밍 :

프로세스와 데이터가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식

→ 변경이 생기더라도 프로세스와 데이터가 모두 동일한 모듈 내부에 있으므로 변경으로 인한 여파가 여러 클래스로 전파되지는 않는다.

<aside>
💡 훌륭한 객체지향 설계? → 캡슐화를 이용해 의존성을 적절히 관리하면서 객체 사이의 결합도를 낮추는 것.

</aside>

- 이러한 관점에서, 한 객체 자신의 문제를 자신이 해결하고 그로 인한 영향을 객체 외부에 파급시키지 않도록 제어하는 것.

### 책임의 이동

![image](https://github.com/somefood/cs-study/assets/104557007/4f40ef0c-28a8-4365-9df7-50c5b12fe1b7)

- 책임이 Theater에 집중되어 있음.

![image](https://github.com/somefood/cs-study/assets/104557007/0505a3d6-236c-44cf-9e45-8955bd0d4c08)

- 책임이 적절하게 분산되어 있음 → 하나의 기능을 완성하는 데 필요한 책임이 여러 객체에 분산

객체지향 설계에서 객체는 **자신을 스스로 책임**진다.

편협한 시각이지만, 객체지향 프로그래밍을 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식으로 표현.

### 결론

---

<aside>
💡 설계를 어렵게 하는 것은, **의존성**

</aside>

- 불필요한 의존성을 제거하면서 객체 사이의 **결합도**를 낮추자.
- 결합도를 낮추기 위해서는? **캡슐화**
- 불필요한 세부사항을 객체 내부로 캡슐화 하는 것은 **자율성**을 높이고 **응집도** 높은 객체들의 공동체를 창조.

의인화 : 

객체들을 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙

### 설계가 필요한 이유

---

설계란 코드를 배치하는 것이다.

좋은 설계? 

프로그램은 두 가지 요구사항을 만족시켜야 한다.

1. 기능 구현
2. **변경 용이**

항상 요구사항이 변경되기 때문에 변경이 용이 하게 코드를 배치해야 한다.

변경 가능한 코드란 이해하기 쉬운 코드. 

반복해서 계속 나오지만, 훌륭한 객체지향 설계는 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계.
