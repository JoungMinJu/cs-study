## 6장

## 메시지와 인터페이스

객체지향 애플리케이션의 가장 중요한 재료 : 객체들이 주고받는 메시지.

- 객체가 수신하는 메시지들이 객체의  퍼블릭 인터페이스를 구성한다.

### 클라이언트 - 서버 모델

- 협력 = 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
- 메세지 = 객체 사이의 협력을 가능하게 하는 매개체 + 타 객체에게 접근할 수 있는 유일한 방법
- **클라이언트 : 협력 안에서 메시지를 전송하는 객체**
- **서버 : 메시지를 수신하는 객체**
- **협력 = 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용**
- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행한다.
- **객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것.**

### 용어정리

### 메시지와 메시지 전송

- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
- 오퍼레이션명[메서드 명]과 인자[파라미터]로 구성

### 메시지와 메서드

- **메서드 : 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저**

### 퍼블릭 인터페이스와 오퍼레이션

- 외부에서 객체를 볼 때 안쪽은 검은 장막으로 가려진 미지의 영역. 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용 할 수 있다.
    - 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스라고 부른다.**
    - 퍼블릭 인터페이스에 포함된 메시지 = **오퍼레이션**
        - 오퍼레이션 = 수행 가능한 어떤 행동에 대한 추상화
        - 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분.
        - EX ] **DiscountCondition 인터페이스에 정의된 isSatisfiedBy**가 오퍼레이션에 해당.
        - **메서드 : 메시지를 수신했을 때 실제로 실행되는 코드**

### 시그니처

- **시그니처 : 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합친 것**
- 오퍼레이션은 실행 코드 ㅇ벗이 시그니처만을 정의한 것.
- 메서드는 이 시그니처에 구현을 더한 것.

## 인터페이스와 설계 품질

- 좋은 인터페이스 = **최소한의 인터페이스와 추상적인 인터페이스**
- 책임 주도 설계 방법은 **메시지를 먼저 선택함에** 따라 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지.

### 디미터 법칙

- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 무넺를 해결하기 위해 제안된 원칙
- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것.
- 디미터 법칙을 따리기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그램이해야 된다.
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체
- 디미터 법칙을 따르면 부끄럼타는 코드(shy code)를 작성할 수 있다.
    - shy code는 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드.
- 디미터원칙
    - screening.g원

### 묻지 말고 시켜라

- 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반하는 것.

### 의도를 드러내는 인터페이스

- 메서드의 이름을 짓는 첫 번째 방법은 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것.
- 메서드의 이름을 짓는 두 번째 방법은 ‘어떻게’가 아니라 ‘무엇’을 하는지를 드러내는 것.

### 함께 모으기

- 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리원칙을 위반.

## 명령-쿼리 분리 원칙

- 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
    - 루틴 = 프로시저 + 함수
    - 프로시저 = 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
    - 함수 = 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류
    - 프로시저는 부수효과를 발생시킬 수 있지만 **값을 반환할 수 없다.**
    - 함수는 값을 반환할 수 있지만 **부수효과를 발생시킬 수 없다.**
- **객체의 상태를 수정하는 오퍼레이션을 명령 = 프로시저**
- **객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리 = 함수**
- 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.
- 명령-쿼리 분리 원칙은 객체들을 독립적인 기계로 보는 객체지향의 오랜 전통에 기인.
- 명령과 쿼리를 분리해서 얻게되는 장점은 무엇?
    
    ### 반복 일정의 명령과 쿼리 분리하기
    
    - 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.
    
    ### 참조 투명성
    
    - 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
    - 참조 투명성을 만족하는 식은
        - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
        - 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
    - 객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.
    - 그러나, 명령-쿼리 분리 원칙을 사용한다면, 조금 균열은 줄일 수 있다.

### 책임에 초점을 맞춰라.

메시지를 먼저 선택한다면,

- 디미터 법칙
    - 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다. 수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어지기 때문. 그렇기에 의도적으로 디미터 법칙을 위반할 위험 최소화 가능
- 묻지 말고 시켜라
    - 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다. 클라이언트의 관점에서 메시지를 선택하기에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.
- 의도를 드러내는 인터페이스
    - 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다. 당연히 그 이름에는 클라이언트가 무엇을 원하는지  그 의도가 분명하게 드러날 수 밖에 없다.
- 명령-쿼리 분리 원칙
    - 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다. 객체가 단순히 어떤 일을 해야 하는지뿐만 아니라, 협력 속에서 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. 따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.

책임 주도 설계 방법에 따라 메시지가 객체를 결정하게 하라.